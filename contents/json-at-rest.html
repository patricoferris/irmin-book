<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JSON at Rest - Real World Irmin</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/what-is-irmin.html"><strong aria-hidden="true">1.1.</strong> What is Irmin?</a></li><li class="chapter-item expanded "><a href="../intro/key-concepts.html"><strong aria-hidden="true">1.2.</strong> Key Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="../architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../arch/functors.html"><strong aria-hidden="true">2.1.</strong> A primer on functors</a></li><li class="chapter-item expanded "><a href="../arch/schemas.html"><strong aria-hidden="true">2.2.</strong> Schemas</a></li><li class="chapter-item expanded "><a href="../arch/runtime-types.html"><strong aria-hidden="true">2.3.</strong> Runtime Types</a></li><li class="chapter-item expanded "><a href="../arch/backend.html"><strong aria-hidden="true">2.4.</strong> Backend Storage</a></li><li class="chapter-item expanded "><a href="../arch/portability.html"><strong aria-hidden="true">2.5.</strong> MirageOS-style Portability</a></li></ol></li><li class="chapter-item expanded "><a href="../store_contents.html"><strong aria-hidden="true">3.</strong> Contents of the Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contents/mergeable-datatypes.html"><strong aria-hidden="true">3.1.</strong> Mergeable Datatypes</a></li><li class="chapter-item expanded "><a href="../contents/json-at-rest.html" class="active"><strong aria-hidden="true">3.2.</strong> JSON at Rest</a></li></ol></li><li class="chapter-item expanded "><a href="../sync.html"><strong aria-hidden="true">4.</strong> Synchronisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sync/pull.html"><strong aria-hidden="true">4.1.</strong> Pulling remote data</a></li><li class="chapter-item expanded "><a href="../sync/push.html"><strong aria-hidden="true">4.2.</strong> Pushing Data</a></li></ol></li><li class="chapter-item expanded "><a href="../intf.html"><strong aria-hidden="true">5.</strong> Public Interfaces for Irmin Stores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intf/cli.html"><strong aria-hidden="true">5.1.</strong> Command-line Interface</a></li><li class="chapter-item expanded "><a href="../intf/graphql.html"><strong aria-hidden="true">5.2.</strong> GraphQL Interface</a></li><li class="chapter-item expanded "><a href="../intf/irmin-server.html"><strong aria-hidden="true">5.3.</strong> Irmin-server Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../todo/intro.html"><strong aria-hidden="true">6.</strong> Mergeable TODO application</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Real World Irmin</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="json-at-rest"><a class="header" href="#json-at-rest">JSON at Rest</a></h1>
<p>As has been mentioned many times, Irmin is fundamentally a key-value store. Thanks to its portability and flexibility both in storage backend and data format, Irmin is not the only means by which to interact with the data.</p>
<h3 id="storing-json-values"><a class="header" href="#storing-json-values">Storing JSON values</a></h3>
<p>We can instantiate a simple in-memory Irmin store that stores JSON objects.</p>
<pre><code class="language-ocaml">module Store = Irmin_mem.KV.Make (Irmin.Contents.Json)
let info () = Store.Info.v (Unix.gettimeofday () |&gt; Int64.of_float)
</code></pre>
<p>The type of JSON objects is identical to that of the <a href="https://github.com/mirage/ezjsonm">Ezjsonm</a> library. The objects are <em>association lists</em> (lists of pairs where the first pair is a string, like a dictionary in other programming languages).</p>
<pre><code class="language-ocaml"># #show Irmin.Contents.Json.t;;
val t : Store.contents Repr.ty
type nonrec t = (string * Irmin.Contents.json) list
</code></pre>
<p>This is very convenient, and we can quickly get and set values directly in the store using JSON-like OCaml values. The fact that the Ezjsonm representation of JSON values and the Irmin representation are the same is no coincidence, however, there is no strict dependency between the two so they could change in the future.</p>
<pre><code class="language-ocaml"># let set_json_string_exn s k v =
  match Ezjsonm.value_from_string v with
  | `O assoc -&gt; Store.set_exn ~info s k assoc
  | _ -&gt; Lwt.fail (Failure &quot;Expected a JSON object as a string&quot;);;
val set_json_string_exn : Store.t -&gt; Store.path -&gt; string -&gt; unit Lwt.t =
  &lt;fun&gt;
</code></pre>
<p>From here we can now add JSON objects directly into the store.</p>
<pre><code class="language-ocaml"># let config = Irmin_mem.config () in
  let* repo = Store.Repo.v config in
  let* main = Store.main repo in
  let* () = set_json_string_exn main [ &quot;a&quot; ] {|{ &quot;hello&quot;: &quot;world&quot; }|} in
  let+ s = Store.get main [ &quot;a&quot; ] in
  print_endline @@ Ezjsonm.value_to_string (`O s);;
{&quot;hello&quot;:&quot;world&quot;}
- : unit = ()
</code></pre>
<h3 id="custom-types-stored-as-json"><a class="header" href="#custom-types-stored-as-json">Custom Types Stored as JSON</a></h3>
<p>One problem with using <code>Irmin.Contents.Json.t</code> is that we've lost the richness of the OCaml type system to a certain extent. This means it isn't obvious what are store is actually storing. Is it random JSON objects or a serialisation of a more rich OCaml value? If it is the latter, it probably isn't the interface we want.</p>
<p>For example, consider the following simple message datatype.</p>
<pre><code class="language-ocaml">module type Message = sig
  type t = string [@@deriving irmin]

  include Irmin.Contents.S with type t := t
end

module Message : Message = struct
  type t = string [@@deriving irmin]

  let merge ~old:_ a b =
    match String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<p>By default if we create a store with this content type, the data will be stored using the string representation defined in <a href="https://github.com/mirage/repr">repr</a>. For the most part this is actually quite JSON-like.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_string Message.t &quot;Hello World&quot;;;
- : string = &quot;Hello World&quot;
</code></pre>
<p>But there is an actual JSON-backend to the representation.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_json_string Message.t &quot;Hello World&quot;;;
- : string = &quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>In fact for the most part the encoding does use JSON to format the OCaml values. The difference are usually very subtle, for example OCaml strings are just bytes whereas for JSON they must be UTF-8. So we can get very different formats (or as above where the JSON string requires the inverted-commas).</p>
<pre><code class="language-ocaml">let _no_output_because_utf8 = Irmin.Type.to_string Message.t &quot;\xc3\x28&quot;
</code></pre>
<p>Whereas we must convert to a UTF-8 string that we can serialise and deserialise.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_json_string Message.t &quot;\xc3\x28&quot;;;
- : string = &quot;{\&quot;base64\&quot;:\&quot;wyg=\&quot;}&quot;
</code></pre>
<p>Fortunately, we can override the runtime representation of the type Irmin uses to store the values and keep the richness of the actual type when programming with the Irmin interface, but be serialising the data into JSON values. This is particularly useful, for example, with the <code>Git.FS</code> backend to read and write JSON values in Git stores.</p>
<pre><code class="language-ocaml">module Message_json : Message = struct
  type t = string [@@deriving irmin]

  let merge ~old:_ a b =
    match String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b

  let t = Irmin.(Type.like ~pp:(Type.pp_json t) ~of_string:(Type.of_json_string t) t)
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<h3 id="care-with-serialisation-of-your-types"><a class="header" href="#care-with-serialisation-of-your-types">Care with Serialisation of your Types</a></h3>
<p>One thing to watch out for with serialisation of types is that it won't be applied
recursively to all of your types. Consider the following defintion where we make 
an indirection via a type alise and forget we haven't converted the <code>name_t</code> to use
JSON.</p>
<pre><code class="language-ocaml">module Message_json = struct
  type name = string [@@deriving irmin]
  type t = name list [@@deriving irmin]

  let merge ~old:_ a b =
    match List.compare String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b

  let t = Irmin.(Type.like ~pp:(Type.pp_json t) ~of_string:(Type.of_json_string t) t)
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<p>Now if we accidently used <code>Message_json.name_t</code> directly it won't be like <code>Message_json.t</code>.</p>
<pre><code class="language-ocaml"># let msg = [ &quot;\xc3\x28&quot; ] in
  let v = Fmt.str &quot;%s&quot; Irmin.Type.(to_string Message_json.t msg) in
  let v' = Fmt.str &quot;[%a]&quot; Fmt.(list string) (List.map Irmin.Type.(to_string Message_json.name_t) msg) in
  v = v';;
- : bool = false
</code></pre>
<p>This example is pretty contrived, but it is meant to just show the problem rather than an exact
real-world example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../contents/mergeable-datatypes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../sync.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../contents/mergeable-datatypes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../sync.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
