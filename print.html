<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real World Irmin</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/what-is-irmin.html"><strong aria-hidden="true">1.1.</strong> What is Irmin?</a></li><li class="chapter-item expanded "><a href="intro/key-concepts.html"><strong aria-hidden="true">1.2.</strong> Key Concepts</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arch/functors.html"><strong aria-hidden="true">2.1.</strong> A primer on functors</a></li><li class="chapter-item expanded "><a href="arch/schemas.html"><strong aria-hidden="true">2.2.</strong> Schemas</a></li><li class="chapter-item expanded "><a href="arch/runtime-types.html"><strong aria-hidden="true">2.3.</strong> Runtime Types</a></li><li class="chapter-item expanded "><a href="arch/backend.html"><strong aria-hidden="true">2.4.</strong> Backend Storage</a></li><li class="chapter-item expanded "><a href="arch/portability.html"><strong aria-hidden="true">2.5.</strong> MirageOS-style Portability</a></li></ol></li><li class="chapter-item expanded "><a href="store_contents.html"><strong aria-hidden="true">3.</strong> Contents of the Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contents/mergeable-datatypes.html"><strong aria-hidden="true">3.1.</strong> Mergeable Datatypes</a></li><li class="chapter-item expanded "><a href="contents/json-at-rest.html"><strong aria-hidden="true">3.2.</strong> JSON at Rest</a></li><li class="chapter-item expanded "><a href="contents/versioned-data.html"><strong aria-hidden="true">3.3.</strong> Versioned Data</a></li></ol></li><li class="chapter-item expanded "><a href="sync.html"><strong aria-hidden="true">4.</strong> Synchronisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sync/pull.html"><strong aria-hidden="true">4.1.</strong> Pulling remote data</a></li><li class="chapter-item expanded "><a href="sync/push.html"><strong aria-hidden="true">4.2.</strong> Pushing Data</a></li></ol></li><li class="chapter-item expanded "><a href="intf.html"><strong aria-hidden="true">5.</strong> Public Interfaces for Irmin Stores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intf/cli.html"><strong aria-hidden="true">5.1.</strong> Command-line Interface</a></li><li class="chapter-item expanded "><a href="intf/graphql.html"><strong aria-hidden="true">5.2.</strong> GraphQL Interface</a></li><li class="chapter-item expanded "><a href="intf/irmin-server.html"><strong aria-hidden="true">5.3.</strong> Irmin-server Interface</a></li></ol></li><li class="chapter-item expanded "><a href="todo/intro.html"><strong aria-hidden="true">6.</strong> Mergeable TODO application</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Real World Irmin</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <strong>Real World Irmin</strong>. This book is all about <a href="https://github.com/mirage/irmin">Irmin</a>.</p>
<blockquote>
<p>Irmin is an OCaml library for building mergeable, branchable distributed data stores.</p>
<ul>
<li><strong>Built-in Snapshotting</strong> - backup and restore</li>
<li><strong>Storage Agnostic</strong> - you can use Irmin on top of your own storage layer</li>
<li><strong>Custom Datatypes</strong> - (de)serialization for custom data types, derivable via ppx_irmin</li>
<li><strong>Highly Portable</strong> - runs anywhere from Linux to web browsers and Xen unikernels</li>
<li><strong>Git Compatibility</strong> - irmin-git uses an on-disk format that can be inspected and modified using Git</li>
<li><strong>Dynamic Behavior</strong> - allows the users to define custom merge functions, use in-memory transactions 
(to keep track of reads as well as writes) and to define event-driven workflows using a
notification mechanism</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-irmin"><a class="header" href="#what-is-irmin">What is Irmin?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-primer-on-functors"><a class="header" href="#a-primer-on-functors">A Primer on Functors</a></h1>
<p>Programming applications in Irmin requires a familiarity with OCaml's functors. Here are a few resources for learning more about them:</p>
<ul>
<li><a href="https://v2.ocaml.org/releases/4.14/htmlman/moduleexamples.html#s%3Afunctors">The OCaml manual</a>: The definitive guide to different aspects of the OCaml language.</li>
</ul>
<p>What follows is an Irmin-specific introduction to functors.</p>
<h2 id="generalisation"><a class="header" href="#generalisation">Generalisation</a></h2>
<p>Functors, in a non-theoretical sense, can be thought of as functions over modules. A functor takes a module and produces another module. For example, we might produce a new module that hashes values provided they can be serialised to a string.</p>
<pre><code class="language-ocaml">(* A module signature for modules who have a main type called [t]
   and that provide a function [serialise] to convert [t] to a [string]. *)
module type Serialisable = sig
    type t
    val serialise : t -&gt; string
end
</code></pre>
<p>We will also need another module signature describing what a digestable type looks like.</p>
<pre><code class="language-ocaml">module type Digestable = sig
    type t
    (** The values to digest *)

    type hash
    (** The type of digests produced *)

    val hash_to_string : hash -&gt; string
    (** Convert digests to a string *)

    val digest : t -&gt; hash
end
</code></pre>
<p>We could then provide a SHA256 hashing functor for serialisable types.</p>
<pre><code class="language-ocaml">module SHA256 (S : Serialisable) : Digestable with type t = S.t and type hash = Digestif.SHA256.t = struct
    type t = S.t
    type hash = Digestif.SHA256.t
    let hash_to_string = Digestif.SHA256.to_raw_string
    let digest v = Digestif.SHA256.digest_string (S.serialise v)
end
</code></pre>
<p>We can then use our functor.</p>
<pre><code class="language-ocaml">module Integer = struct
  type t = int
  let serialise = string_of_int
end

module Digest_int = SHA256(Integer)
</code></pre>
<p>And then use it.</p>
<pre><code class="language-ocaml"># let d = Digest_int.digest 42;;
val d : Digest_int.hash = &lt;abstr&gt;
# Digest_int.hash_to_string d |&gt; Base64.encode_exn;;
- : string = &quot;c0dctApWjo2ooEXO0RATfhWfiQrE2og7axfcZRs6gEk=&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schemas"><a class="header" href="#schemas">Schemas</a></h1>
<p>Every Irmin store has a schema. This specifies the concrete implementations of the various kinds of customisable aspects of the store. For example what type are the keys, the branches and the contents.</p>
<p>In Irmin everything gets specified upfront using functor application. Whereas with something like <code>Hashtbl</code> its type will be inferred but its use.</p>
<p>Most stores take a <code>Schema</code> module to provide the concrete implementation of the various customisable parts of the Irmin store. This can be a little verbose, but most of the time the defaults are just fine.</p>
<pre><code class="language-ocaml">module Schema : Irmin.Schema.S = struct
  open Irmin
  module Hash = Hash.BLAKE2B
  module Info = Info.Default
  module Branch = Branch.String
  module Path = Path.String_list
  module Metadata = Metadata.None
  module Contents = struct
    type t = int[@@deriving irmin]
    let merge = Irmin.Merge.(option @@ default t) 
  end
end
module S = Irmin_mem.Make (Schema)
(* A fake clock and info function for our commits *)
let clock = let time = ref 0L in fun () -&gt; time := Int64.add !time 1L; !time
let info () = S.Info.v (clock ())
</code></pre>
<p>Here we've defined a schema to use Blake2B hash functions, default commit information, branches are strings, keys (or paths) are string lists, no extra metadata and finally the content of the store is integers.</p>
<p>However, we'll quickly run into problems as soon as we try to use the store.</p>
<pre><code class="language-ocaml"># let config = Irmin_mem.config () in
  let* repo = S.Repo.v config in
  let* main = S.main repo in
  let* () = S.set_exn ~info main [ &quot;hello&quot; ] 1 in
  S.get main [ &quot;hello&quot; ];;
Line 4, characters 34-45:
Error: This expression has type 'a list
       but an expression was expected of type S.path
</code></pre>
<p>This is because in our definition of the schema we <em>hid</em> the implementation details by adding <code>: Irmin.Schema.S</code>. So either we canleave that part out or we must provide a module type to expose the information (or at the very least the bits we need).</p>
<pre><code class="language-ocaml">module type String_list_int_schema = Irmin.Schema.S 
   with type Hash.t = Irmin.Schema.default_hash
    and type Branch.t = string
    and type Info.t = Irmin.Info.default
    and type Metadata.t = unit
    and type Path.step = string
    and type Path.t = string list
    and type Contents.t = int
</code></pre>
<p>And then use that to define the store.</p>
<pre><code class="language-ocaml">module Schema2 : String_list_int_schema = struct
  open Irmin
  module Hash = Hash.BLAKE2B
  module Info = Info.Default
  module Branch = Branch.String
  module Path = Path.String_list
  module Metadata = Metadata.None
  module Contents = struct
    type t = int[@@deriving irmin]
    let merge = Irmin.Merge.(option @@ default t) 
  end
end
module S = Irmin_mem.Make (Schema2)
let info () = S.Info.v (clock ())
</code></pre>
<p>And now the compiler knows what the types are (they haven't been abstracted away).</p>
<pre><code class="language-ocaml"># let config = Irmin_mem.config () in
  let* repo = S.Repo.v config in
  let* main = S.main repo in
  let* () = S.set_exn ~info main [ &quot;hello&quot; ] 1 in
  S.get main [ &quot;hello&quot; ];;
- : int = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-types"><a class="header" href="#runtime-types">Runtime Types</a></h1>
<p>One thing that will quickly become very apparent is the need to define an <code>'a Irmin.Type.t</code> for nearly every type. This is a so-called runtime type. It <em>represents</em> the type <code>'a</code> at runtime as an OCaml value.</p>
<p>Internally it reuses the <a href="https://github.com/mirage/repr">mirage/repr</a> library. Some runtime types come predefined, such as that for boolean values.</p>
<pre><code class="language-ocaml"># Irmin.Type.bool;;
- : bool Repr.ty = &lt;abstr&gt;
</code></pre>
<p>This carries information with it about how to interact with actual <code>bool</code> values, for example how to serialise it in different ways.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_string Irmin.Type.bool true;;
- : string = &quot;true&quot;
# Irmin.Type.to_json_string Irmin.Type.bool true;;
- : string = &quot;true&quot;
</code></pre>
<h2 id="ppx_irmin"><a class="header" href="#ppx_irmin">ppx_irmin</a></h2>
<p>Because so many modules and functions expect a runtime type, Irmin provides a ppx that can in the majority of cases derive the runtime representation of your type for you.</p>
<pre><code class="language-ocaml"># type t = { name : string }[@@deriving irmin];;
type t = { name : string; }
val t : t Repr.ty = &lt;abstr&gt;
</code></pre>
<p>You can see that this created a <em>value</em> called <code>t</code> (not to be confused with the type itself). </p>
<pre><code class="language-ocaml"># Irmin.Type.to_string t { name = &quot;Bob&quot; };;
- : string = &quot;{\&quot;name\&quot;:\&quot;Bob\&quot;}&quot;
</code></pre>
<p>You can also build up representations of more complex types using the built-in combinators.</p>
<pre><code class="language-ocaml"># let t = Irmin.Type.(list (pair string (option int)));;
val t : (string * int option) list Repr.ty = &lt;abstr&gt;
</code></pre>
<h2 id="uses"><a class="header" href="#uses">Uses</a></h2>
<p>Irmin mainly uses the runtime types for serialisation purposes. For example if your Irmin store is using the file system backend (<code>Irmin.FS</code>) then Irmin needs to know how to turn your contents into a string and your key into a file path. Conversely, it will need to know how to turn file paths into your path type and file contents into your content type.</p>
<pre><code class="language-ocaml"># let s = Irmin.Type.to_string t [ &quot;key1&quot;, Some 1; &quot;key2&quot;, None ];;
val s : string = &quot;[[\&quot;key1\&quot;,{\&quot;some\&quot;:1}],[\&quot;key2\&quot;,null]]&quot;
# let v = Irmin.Type.of_string t s;;
val v : ((string * int option) list, [ `Msg of string ]) result =
  Ok [(&quot;key1&quot;, Some 1); (&quot;key2&quot;, None)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backends"><a class="header" href="#backends">Backends</a></h1>
<p>An Irmin backend describes how data is persisted. By abstracting over some notion of backend, Irmin can:</p>
<ul>
<li>Be very portable. See the <a href="arch/">portability</a> section for more details.</li>
<li>Be very efficient for specific datatypes. You can image providing a highly specific backend for use with your specific datatype.</li>
</ul>
<p>There are lots of pre-existing backends including:</p>
<ul>
<li><code>Irmin_mem</code>: the in-memory backend. No data is actually persisted.</li>
<li><code>Irmin_fs</code>: a Unix filesystem implementation where there's a natural mapping from the steps in your path (key) implementation to file paths and your contents are stored in files.</li>
<li><code>Irmin_indexeddb</code>: a slightly more experimental backend that uses the browser's IndexedDB storage API.</li>
<li><code>Irmin_pack</code>: another filesystem-based backend but using <a href="arch/">pack</a> files.</li>
</ul>
<h2 id="making-a-backend"><a class="header" href="#making-a-backend">Making a Backend</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mirageos-style-portability"><a class="header" href="#mirageos-style-portability">MirageOS-style Portability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contents-of-the-store"><a class="header" href="#contents-of-the-store">Contents of the Store</a></h1>
<p><a href="https://irmin.org%7D%7D">Irmin</a> is a key-value store. The contents of the store references the value part.</p>
<p>This next section will cover basic concepts you might want to impose on your contents such as:</p>
<ul>
<li>How to define three-way merge functions for your contents.</li>
<li>Always serialise the contents to JSON.</li>
<li>Version your content store so you can update the type in the future.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mergeable-datatypes"><a class="header" href="#mergeable-datatypes">Mergeable Datatypes</a></h1>
<p>Contents in <a href="https://irmin.org">Irmin</a> are <em>mergeable datatypes</em> (MDT). These are values that have a three-way merge function. If you are familiar with the <code>git</code> version control system then the idea will hopefully be familiar.</p>
<p>Whenever you want to store some new value <code>x</code> in an Irmin store <code>S</code> at key <code>k</code>, there are two other <em>versions</em> of <code>x</code> to consider.</p>
<ol>
<li>The current version of <code>x</code> in store <code>S</code> at key <code>k</code> let's call it <code>x'</code>.</li>
<li>The shared <strong>lowest-common ancestor</strong> (LCA) of <code>x</code> and <code>x'</code> in store <code>S</code> at key <code>k</code> let's call it <code>lca</code>.</li>
</ol>
<p>A merge function takes these three values and either produces some &quot;merged&quot; value or we have a merge conflict and we return an error. A merge function for values of type <code>'a</code> are of type <code>'a Irmin.Merge.f</code>.</p>
<pre><code class="language-ocaml"># #show_type Irmin.Merge.f;;
type nonrec 'a f =
    old:'a Irmin.Merge.promise -&gt;
    'a -&gt; 'a -&gt; ('a, Irmin.Merge.conflict) result Lwt.t
</code></pre>
<p>Let's take a look at a few examples.</p>
<h2 id="mergeable-counters"><a class="header" href="#mergeable-counters">Mergeable Counters</a></h2>
<p>The classic MDT is a counter, an integer value that can be incremented and decremented.</p>
<pre><code class="language-ocaml">module Counter = struct
  type t = int [@@deriving irmin]
  let incr t = t + 1
  let decr t = t - 1
end
</code></pre>
<p>By using <code>ppx_irmin</code> we derive a runtime representation of the type <code>t</code>. This creates a <em>value</em> in the module called <code>t</code>. We're not quite ready to use our new module to instantiate a new, in-memory key-value Irmin store though.</p>
<pre><code class="language-ocaml"># module Store = Irmin_mem.KV.Make (Counter);;
Line 1, characters 16-43:
Error: Modules do not match:
       sig
         type t = int
         val t : t Repr__Type.t
         val incr : t -&gt; t
         val decr : t -&gt; t
       end
     is not included in Irmin__.Contents.S
     The value `merge' is required but not provided
     File &quot;src/irmin/contents_intf.ml&quot;, line 25, characters 2-30:
       Expected declaration
</code></pre>
<p>We need to provide a merge function! What properties should it have? The main one is probably that simultaneous increments and/or decrements should not be lost in the new merged value.</p>
<p>For example if Alice has a copy of the counter and increments it five times and Bob has a copy and decrements it twice, the final merged counter should be the lowest common ancestor plus five minus two.</p>
<pre><code class="language-ocaml">module Counter = struct
  type t = int [@@deriving irmin]
  let incr t = t + 1
  let decr t = t - 1

  let merge ~old t1 t2 =
    let open Irmin.Merge.Infix in
    old () &gt;&gt;=* fun old -&gt;
    let old = match old with None -&gt; 0 | Some v -&gt; v in
    let diff1 = t1 - old in
    let diff2 = t2 - old in
    Fmt.pr &quot;LCA: %i, Diff1: %i, Diff2: %i%!&quot; old diff1 diff2;
    Irmin.Merge.ok (old + diff1 + diff2)

  let merge = Irmin.Merge.(option (v t merge))
end
module Store = Irmin_mem.KV.Make (Counter)
let info () = Store.Info.v (Unix.gettimeofday () |&gt; Int64.of_float);;
</code></pre>
<p>Note that the merge function here contains a print statement that you might actually debug log (with <code>Logs.debug</code>) to show the two diffs whenever the merge function is called. This is so we can see what is happening later on.</p>
<p>From here we can recreate the scenario between Alice and Bob. We'll use different branches to represent multiple stores.</p>
<pre><code class="language-ocaml">let alice_action s =
  let* v = Store.get s [ &quot;counter&quot; ] in
  let c =
    Counter.incr v
    |&gt; Counter.incr
    |&gt; Counter.incr
    |&gt; Counter.incr
    |&gt; Counter.incr
  in
  Store.set_exn ~info s [ &quot;counter&quot; ] c

let bob_action s =
  let* v = Store.get s [ &quot;counter&quot; ] in
  let c =
    Counter.decr v
    |&gt; Counter.decr
  in
  Store.set_exn ~info s [ &quot;counter&quot; ] c
</code></pre>
<p>Now for the main function which initialises the main store and applies both Alice's and Bob's actions and tries to merge them into the store.</p>
<pre><code class="language-ocaml"># let config = Irmin_mem.config () in
  (* Initialise a new empty store and add counter with value 10 *)
  let* repo = Store.Repo.v config in
  let* main = Store.main repo in
  let* () = Store.set_exn ~info main [ &quot;counter&quot; ] 10 in

  (* Create two new branches as clones of the [main] branch *)
  let* alice_branch = Store.clone ~src:main ~dst:&quot;alice&quot; in
  let* bob_branch = Store.clone ~src:main ~dst:&quot;bob&quot; in

  (* Apply the actions *)
  let* () = alice_action alice_branch in
  let* () = bob_action bob_branch in

  (* Merge the results *)
  let* () =
    let+ merge = Store.merge_into ~into:main ~info alice_branch in
    Result.get_ok merge
  in
  let* () =
    let+ merge = Store.merge_into ~into:main ~info bob_branch  in
    Result.get_ok merge
  in
  Store.get main [ &quot;counter&quot; ];;
LCA: 10, Diff1: -2, Diff2: 5
- : int = 13
</code></pre>
<p>The merge function was only needed once. When <code>alice_action</code> is applied, it is a simple &quot;fast-forward&quot; merge because there is no three-way merge required. However, when <code>bob_action</code> is applied there is now the LCA (the initial <code>10</code> value), Bob's new value (<code>8</code>) and Alice's value that has been merged (<code>15</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-at-rest"><a class="header" href="#json-at-rest">JSON at Rest</a></h1>
<p>As has been mentioned many times, Irmin is fundamentally a key-value store. Thanks to its portability and flexibility both in storage backend and data format, Irmin is not the only means by which to interact with the data.</p>
<h3 id="storing-json-values"><a class="header" href="#storing-json-values">Storing JSON values</a></h3>
<p>We can instantiate a simple in-memory Irmin store that stores JSON objects.</p>
<pre><code class="language-ocaml">module Store = Irmin_mem.KV.Make (Irmin.Contents.Json)
let info () = Store.Info.v (Unix.gettimeofday () |&gt; Int64.of_float)
</code></pre>
<p>The type of JSON objects is identical to that of the <a href="https://github.com/mirage/ezjsonm">Ezjsonm</a> library. The objects are <em>association lists</em> (lists of pairs where the first pair is a string, like a dictionary in other programming languages).</p>
<pre><code class="language-ocaml"># #show Irmin.Contents.Json.t;;
val t : Store.contents Repr.ty
type nonrec t = (string * Irmin.Contents.json) list
</code></pre>
<p>This is very convenient, and we can quickly get and set values directly in the store using JSON-like OCaml values. The fact that the Ezjsonm representation of JSON values and the Irmin representation are the same is no coincidence, however, there is no strict dependency between the two so they could change in the future.</p>
<pre><code class="language-ocaml"># let set_json_string_exn s k v =
  match Ezjsonm.value_from_string v with
  | `O assoc -&gt; Store.set_exn ~info s k assoc
  | _ -&gt; Lwt.fail (Failure &quot;Expected a JSON object as a string&quot;);;
val set_json_string_exn : Store.t -&gt; Store.path -&gt; string -&gt; unit Lwt.t =
  &lt;fun&gt;
</code></pre>
<p>From here we can now add JSON objects directly into the store.</p>
<pre><code class="language-ocaml"># let config = Irmin_mem.config () in
  let* repo = Store.Repo.v config in
  let* main = Store.main repo in
  let* () = set_json_string_exn main [ &quot;a&quot; ] {|{ &quot;hello&quot;: &quot;world&quot; }|} in
  let+ s = Store.get main [ &quot;a&quot; ] in
  print_endline @@ Ezjsonm.value_to_string (`O s);;
{&quot;hello&quot;:&quot;world&quot;}
- : unit = ()
</code></pre>
<h3 id="custom-types-stored-as-json"><a class="header" href="#custom-types-stored-as-json">Custom Types Stored as JSON</a></h3>
<p>One problem with using <code>Irmin.Contents.Json.t</code> is that we've lost the richness of the OCaml type system to a certain extent. This means it isn't obvious what are store is actually storing. Is it random JSON objects or a serialisation of a more rich OCaml value? If it is the latter, it probably isn't the interface we want.</p>
<p>For example, consider the following simple message datatype.</p>
<pre><code class="language-ocaml">module type Message = sig
  type t = string [@@deriving irmin]

  include Irmin.Contents.S with type t := t
end

module Message : Message = struct
  type t = string [@@deriving irmin]

  let merge ~old:_ a b =
    match String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<p>By default if we create a store with this content type, the data will be stored using the string representation defined in <a href="https://github.com/mirage/repr">repr</a>. For the most part this is actually quite JSON-like.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_string Message.t &quot;Hello World&quot;;;
- : string = &quot;Hello World&quot;
</code></pre>
<p>But there is an actual JSON-backend to the representation.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_json_string Message.t &quot;Hello World&quot;;;
- : string = &quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>In fact for the most part the encoding does use JSON to format the OCaml values. The difference are usually very subtle, for example OCaml strings are just bytes whereas for JSON they must be UTF-8. So we can get very different formats (or as above where the JSON string requires the inverted-commas).</p>
<pre><code class="language-ocaml">let _no_output_because_utf8 = Irmin.Type.to_string Message.t &quot;\xc3\x28&quot;
</code></pre>
<p>Whereas we must convert to a UTF-8 string that we can serialise and deserialise.</p>
<pre><code class="language-ocaml"># Irmin.Type.to_json_string Message.t &quot;\xc3\x28&quot;;;
- : string = &quot;{\&quot;base64\&quot;:\&quot;wyg=\&quot;}&quot;
</code></pre>
<p>Fortunately, we can override the runtime representation of the type Irmin uses to store the values and keep the richness of the actual type when programming with the Irmin interface, but be serialising the data into JSON values. This is particularly useful, for example, with the <code>Git.FS</code> backend to read and write JSON values in Git stores.</p>
<pre><code class="language-ocaml">module Message_json : Message = struct
  type t = string [@@deriving irmin]

  let merge ~old:_ a b =
    match String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b

  let t = Irmin.(Type.like ~pp:(Type.pp_json t) ~of_string:(Type.of_json_string t) t)
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<h3 id="care-with-serialisation-of-your-types"><a class="header" href="#care-with-serialisation-of-your-types">Care with Serialisation of your Types</a></h3>
<p>One thing to watch out for with serialisation of types is that it won't be applied
recursively to all of your types. Consider the following defintion where we make 
an indirection via a type alise and forget we haven't converted the <code>name_t</code> to use
JSON.</p>
<pre><code class="language-ocaml">module Message_json = struct
  type name = string [@@deriving irmin]
  type t = name list [@@deriving irmin]

  let merge ~old:_ a b =
    match List.compare String.compare a b with
    | 0 -&gt;
        if Irmin.Type.(unstage (equal t)) a b then
            Irmin.Merge.ok a
        else
            let msg = &quot;Conflicting entries have the same timestamp but different values&quot; in
            Irmin.Merge.conflict &quot;%s&quot; msg
    | 1 -&gt; Irmin.Merge.ok a
    | _ -&gt; Irmin.Merge.ok b

  let t = Irmin.(Type.like ~pp:(Type.pp_json t) ~of_string:(Type.of_json_string t) t)
    
  let merge = Irmin.Merge.(option (v t merge))
end
</code></pre>
<p>Now if we accidently used <code>Message_json.name_t</code> directly it won't be like <code>Message_json.t</code>.</p>
<pre><code class="language-ocaml"># let msg = [ &quot;\xc3\x28&quot; ] in
  let v = Fmt.str &quot;%s&quot; Irmin.Type.(to_string Message_json.t msg) in
  let v' = Fmt.str &quot;[%a]&quot; Fmt.(list string) (List.map Irmin.Type.(to_string Message_json.name_t) msg) in
  v = v';;
- : bool = false
</code></pre>
<p>This example is pretty contrived, but it is meant to just show the problem rather than an exact
real-world example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioned-data"><a class="header" href="#versioned-data">Versioned Data</a></h1>
<p>Currently <a href="https://irmin.org">Irmin</a> only supports <em>monomorphic</em> operations over stores, meaning there can
only be one return type from functions like <code>Store.get</code>. On the way to heterogeneity, a logical
first stop is being able to <em>version</em> content datatypes.</p>
<p>Versioning in this sense relates to the type and not the value. Irmin let's you version OCaml values,
but we want to have different versions of the type of that value whilst still preserving key
characteristics of the Irmin store.</p>
<h2 id="changing-the-content-type"><a class="header" href="#changing-the-content-type">Changing the Content Type</a></h2>
<p>Before we do that, let's first look at how it can go wrong. First let's define two types that are meant
to represent the same value but just one version is newer and has added new fields.</p>
<!-- $MDX file=bad-content-store/main.ml,part=contents -->
<pre><code class="language-ocaml">module C1 = struct
  type t = { name : string } [@@deriving irmin]

  let merge = Irmin.Merge.(option @@ default t)
end

module C2 = struct
  type t = { name : string; age : int }[@@deriving irmin]

  let merge = Irmin.Merge.(option @@ default t)
end
</code></pre>
<p>The only difference between the two types is the extra <code>age : int</code> field in <code>C2.t</code>. We can instantiate two Irmin
key-value stores that use the filesystem.</p>
<!-- $MDX file=bad-content-store/main.ml,part=stores -->
<pre><code class="language-ocaml">module S1 = Irmin_fs_unix.KV.Make (C1)
module S2 = Irmin_fs_unix.KV.Make (C2)
</code></pre>
<p>And now we can store a <code>C1.t</code> in the store and try and read it back using the <code>S2</code> interface.</p>
<!-- $MDX file=bad-content-store/main.ml,part=main -->
<pre><code class="language-ocaml">let main () =
  let conf = Irmin_fs.config &quot;./tmp&quot; in
  let* repo = S1.Repo.v conf in
  let* main = S1.main repo in
  let* () = S1.set_exn ~info main [ &quot;a&quot; ] C1.{ name = &quot;Alice&quot; } in
  let* repo = S2.Repo.v conf in
  let* main = S2.main repo in
  let* v = S2.get main [ &quot;a&quot; ] in
  Fmt.pr &quot;Name: %s&quot; v.name;
  Lwt.return_unit
</code></pre>
<p>But this goes wrong if we try running it!</p>
<pre><code class="language-sh">$ ./bad-content-store/main.exe
Fatal error: exception Irmin.Tree.find_all: encountered dangling hash 15942488a5c800c506817379631ace9263149cf42b0c8bc409a5a6e9698d6e5194ff6d178365e1642d9b5b29dee30ed18e5b4605c281a35db7d214428bfff510
[2]
</code></pre>
<h2 id="using-views"><a class="header" href="#using-views">Using Views</a></h2>
<p>The following is courtesy of <a href="https://github.com/samoht">Thomas Gazagnaire</a>.</p>
<h3 id="raw-views"><a class="header" href="#raw-views">Raw views</a></h3>
<p>One way to fix this problem is to abstract the content type behind a view on it. This view
let's us hide some details to the end user whilst giving us the power to do more complex manipulations
of the data we are storing. To begin with, the view contains information about the version of the data.</p>
<!-- $MDX file=views/main.ml,part=raw-types -->
<pre><code class="language-ocaml">  type v1 = { age : int } [@@deriving irmin ~pre_hash]
  type v2 = { age : int; name : string } [@@deriving irmin ~pre_hash]

  type t = V1 of v1 | V2 of v2 [@@deriving irmin]

  (* change depending on what you want to index - here we just skip the
     version field. Can only hash the age (but that will merge values
     with the same hash, so it's not a great index here). *)
  let pre_hash = function
    | V1 v -&gt; pre_hash_v1 v
    | V2 v -&gt; pre_hash_v2 v

  let t = Irmin.Type.like ~pre_hash t
</code></pre>
<p>This code handles serialising the version information so we can re-use that later without polluting
the content-addressable storage with fields we might not have later. For example, a user might only
habe their <code>age</code> and not be aware of the <code>V1</code> version number, but they don't need to be aware of it
for us to do content-addressed lookups for the data.</p>
<p>However, we do need to manage smooth upgrades and downgrades from the versions but this is only verbose,
not complicated.</p>
<!-- $MDX file=views/main.ml,part=raw-helpers -->
<pre><code class="language-ocaml">  let default_name = &quot;Default Name&quot;
  let v1 age = { age }
  let v2 ?(name = default_name) age = { age; name }
  let v1_to_v2 : v1 -&gt; v2 = fun { age } -&gt; v2 age
  let v2_to_v1 : v2 -&gt; v1 = fun { age; _ } -&gt; { age }
  let to_v2 = function V1 v -&gt; v1_to_v2 v | V2 v -&gt; v
  let to_v1 = function V1 v -&gt; v | (V2 _) as v -&gt; v2_to_v1 (to_v2 v)
  let merge_v1 = Irmin.Merge.(default v1_t)
  let merge_v2 = Irmin.Merge.(default v2_t)
</code></pre>
<p>Finally, we need to define a sufficient default merge function over versioned data.</p>
<!-- $MDX file=views/main.ml,part=raw-merge -->
<pre><code class="language-ocaml">  let merge : t Irmin.Merge.t =
    let open Lwt_result.Infix in
    let promise x = Irmin.Merge.promise x in
    let upgrade x = V2 (to_v2 x) in
    let wrap_v1 v = V1 v in
    let wrap_v2 v = V2 v in
    let rec f ~old x y =
      old () &gt;&gt;= fun old -&gt;
      match (old, x, y) with
      | Some (V1 old), V1 x, V1 y -&gt;
          Irmin.Merge.f merge_v1 ~old:(promise old) x y &gt;|= wrap_v1
      | Some (V2 old), V2 x, V2 y -&gt;
          Irmin.Merge.f merge_v2 ~old:(promise old) x y &gt;|= wrap_v2
      | _ -&gt;
          let old =
            match old with
            | None -&gt; fun () -&gt; Lwt.return (Ok None)
            | Some old -&gt; promise (upgrade old)
          in
          f ~old (upgrade x) (upgrade y)
    in
    Irmin.Merge.seq [ Irmin.Merge.default t; Irmin.Merge.v t f ]
</code></pre>
<h3 id="higher-level-abstraction"><a class="header" href="#higher-level-abstraction">Higher-level Abstraction</a></h3>
<p>With our raw views we can now provide a higher-level abstraction to use within our actual Irmin stores.</p>
<!-- $MDX file=views/main.ml,part=view -->
<pre><code class="language-ocaml">type 'a view = { payload : 'a; raw : Raw.t }

let version v = match v.raw with V1 _ -&gt; 1 | V2 _ -&gt; 2

module C1 = struct
  type t = Raw.v1 view

  let of_raw raw =
    let payload = Raw.to_v1 raw in
    { payload; raw }

  let to_raw t = t.raw
  let t = Irmin.Type.map Raw.t of_raw to_raw

  let v age =
    let v = Raw.v1 age in
    { payload = v; raw = V1 v }

  let merge = Irmin.Merge.(option @@ like t Raw.merge to_raw of_raw)
end
</code></pre>
<p>To be concise only <code>V1</code> is shown here but as you can see it reuses all of the <code>Raw</code> values we defined
previously. We can always convert to and from an <code>Raw.t</code> and that is how the runtime value <code>t</code> is defined.
This means if we pull a <code>V2</code> out of the store but the serialised version is a <code>V1</code> we can still deserialise it.</p>
<p>We can use these <code>Content</code> modules for stores now.</p>
<!-- $MDX file=views/main.ml,part=stores -->
<pre><code class="language-ocaml">module S1 = Irmin_fs_unix.KV.Make (C1)
module S2 = Irmin_fs_unix.KV.Make (C2)
</code></pre>
<p>And finally write a program where we interleave the stores, reading old and new values as we go!</p>
<!-- $MDX file=views/main.ml,part=main -->
<pre><code class="language-ocaml">let main () =
  let config = Irmin_fs.config &quot;./tmp2&quot; in
  let* repo = S1.Repo.v config in
  let* main = S1.main repo in
  let* repo2 = S2.Repo.v config in
  let* main2 = S2.main repo2 in
  let c1 = C1.v 42 in
  let _h1 = S1.Contents.hash c1 in
  let* () = S1.set_exn ~info:info1 main [ &quot;a&quot; ] c1 in
  Fmt.pr &quot;Storing S1 at a: { age = %i }\n%!&quot; c1.payload.age;
  let* v1 = S1.get main [ &quot;a&quot; ] in
  Fmt.pr &quot;S1 lookup a: %i (version = %d)\n%!&quot; v1.payload.age (version v1);
  let* v2 = S2.get main2 [ &quot;a&quot; ] in
  Fmt.pr &quot;S2 lookup a: %i (version = %d)\n%!&quot; v2.payload.age (version v2);
  let c2 = C2.v 43 ~name:&quot;Alice&quot; in
  let* () = S2.set_exn ~info:info2 main2 [ &quot;b&quot; ] c2 in
  Fmt.pr &quot;Storing S2 at b: { age = %i; name = %s }\n%!&quot; c2.payload.age c2.payload.name;
  let* v = S2.get main2 [ &quot;a&quot; ] in
  Fmt.pr &quot;S2 lookup a: %s %i (version = %d)\n%!&quot; v.payload.name v.payload.age
    (version v);
  let* v = S1.get main [ &quot;b&quot; ] in
  Fmt.pr &quot;S1 lookup b for age: %i\n%!&quot; v.payload.age;
  Lwt.return_unit
</code></pre>
<p>Let's run the program!</p>
<pre><code class="language-sh">$ ./views/main.exe
Storing S1 at a: { age = 42 }
S1 lookup a: 42 (version = 1)
S2 lookup a: 42 (version = 1)
Storing S2 at b: { age = 43; name = Alice }
S2 lookup a: Default Name 42 (version = 1)
S1 lookup b for age: 43
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronisation"><a class="header" href="#synchronisation">Synchronisation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pulling-remote-data"><a class="header" href="#pulling-remote-data">Pulling remote data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pushing-data"><a class="header" href="#pushing-data">Pushing Data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-interfaces-for-irmin-stores"><a class="header" href="#public-interfaces-for-irmin-stores">Public Interfaces for Irmin Stores</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line Interface</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-interface"><a class="header" href="#graphql-interface">GraphQL Interface</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="irmin-server-interface"><a class="header" href="#irmin-server-interface">Irmin-server Interface</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mergeable-todo-application"><a class="header" href="#mergeable-todo-application">Mergeable TODO application</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
